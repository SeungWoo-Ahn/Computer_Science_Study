## 디자인 패턴
프로그램을 설계할 때 발생했던 문제점들을 
객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 `규약` 형태로 만들어 놓은 것

<br>

### 1. 싱글톤 패턴

    - 하나의 클래스에 '오직 하나의 인스턴스'만 가지는 패턴
    
    - 데이터베이스 연결 모듈에 많이 사용

    - 장점: 같은 인스턴스를 서로 다른 모듈들이 공유하며 사용하기 때문에 인스턴스 생성 비용이 작다.
    그래서 '인스턴스 생성에 많은 비용'이 드는 I/O 바운드 작업(Network, DB, FileSystem)에 많이 사용됨

    - 단점: 
        1. 의존성이 높아진다.
        2. TDD에 걸림돌이 된다
        단위 테스트는 테스트가 서로 독립적이어야 하며 어떤 순서로든 실행할 수 있어야 한다.
        하지만 싱글톤 패턴을 사용하면 각 테스트마다 '독립적인' 인스턴스를 만들기가 어렵다.

    - 단점의 해결책: 의존성 주입
    중간에 의존성 주입자가 하위 모듈에 의존성을 주어, 메인 모듈이 '간접적'으로 의존성을 주입하는 방식
    이를 통해 메인 모듈은 하위 모듈에 대한 의존성이 떨어진다.

### 2. 팩토리 패턴

    - 객체를 사용하는 코드에서 '객체 생성 부분'을 떼어내 '추상화'한 패턴
    상속 관계에 있는 두 클래스에서 상위 클래스는 '중요한 뼈대' 결정, 
    하위 클래스는 '객체 생성'에 관한 구체적인 내용을 결정

    - 장점:
        1. 느슨한 결합: 상위 클래스와 하위 클래스가 분리됨
        2. 유연성: 상위 클래스에선 인스턴스 생성 방식에 대해 알 필요가 없음
        3. 유지 보수성: 객체 생성 로직이 분리돼 한 곳만 고치면 됨

### 3. 전략 패턴

    - 정책 패턴이로고도 하며, 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고
    전략이라고 부르는 '캡슐화한 알고르즘'을 컨텍스트 안에서 바꿔주는 패턴
    ※ 컨텍스트: 상황, 맥락, 문맥을 의미. 개발자가 어떠한 작업을 완료하는데 필요한 모든 정보

    - 하나의 객체가 다양하면서 변화하는 역할을 할 때 사용

    - 예시로 결제할 때, BC카드, 네이버페이, 카카오페이 등 다양한 방법이 있다.
    결제 방식의 '전략'만 바꿔서 결제가 가능하게 만들 수 있다.

### 4. 옵저버 패턴

    - 주체가 객체의 '상태 변화를 관찰'하다가 상태 변화가 있을 때마다
    옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴

    - 주체: 객체의 '상태 변화'를 보고 있는 관찰자

    - MVC 패턴에서 옵저버 패턴
    주체인 '모델'에서 변경 사항이 생기면 옵저버인 '뷰'에 알려주고 이를 기반으로 컨트롤러가 작동

    - 장점
        1. 주체와 객체의 관계를 느슨하게 유지할 수 있다.
        2. 주체의 상태 변경을 주기적으로 조회하지 않고 자동으로 감지
        3. 런타임에 옵저버를 추가하거나 제거할 수 있다.

    - 단점
        1. 복잡도가 증가한다.
        2. 다수의 Observer 객체를 등록 후 해지하지 않으면 '메모리 누수'가 발생할 수 있다.

## 5. 프록시 패턴

    - 대상 객체에 접근하기 전, '접근에 대한 흐름을 가로채` 해당 접근을 필터링하거나 수정하는 등의
    역할을 하는 계층이 있는 디자인 패턴

    - 객체의 속서, 변환을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용

    - 프록시 서버
    서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 '간접적으로'
    접속할 수 있게 해주는 서버
    사용사례)
        1. 포트 번호를 바꿔서 사용자가 실제 서버의 포트에 접근하는 것을 방지
        2. DDOS 공격을 차단하거나 CDN을 프록시 서버로 캐싱
        
    ※ DDOS: 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시키는 공격
    ※ CDN (Content Delivery Network): 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서
    콘텐츠를 캐싱 또는 배포하는 서버 네트워크. 사용자의 콘텐츠 다운로드 시간을 줄일 수 있다.
    
## 6. MVC 패턴

    모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴

    장점: '재사용성'과 '확장성'이 용이
        
    단점: 앱이 복잡해질수록 모델과 뷰의 관계가 복잡

**모델**

    앱의 '데이터' + '상태' + '비즈니스 로직'

    뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신함

**뷰**

    사용자 인터페이스 요소, 즉 사용자가 볼 수 있는 화면

    변경이 일어나면 컨트롤러에 이를 전달

    안드로이드 xml

**컨트롤러**

    하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할, 메인 로직을 담당

    모델과 뷰의 생명주기도 관리

    모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 알림

    안드로이드 Activity, Fragment

    안드로이드 MVC 패턴 컨트롤러의 문제점)
    
    1. 테스트 어려움 - 안드로이드 API에 깊게 종속됐기 때문에

    2. 뷰에 단단히 결합 - 뷰를 변경하면 컨트롤러로 돌아가 변경해야 함

    3. 유지 보수 어려움 - 많은 코드가 컨트롤러에 모이기 때문에

### 7. MVP 패턴

    모델(Model), 뷰(View), 프레젠터(Presenter)로 이루어진 디자인 패턴

    MVC에서 파생, 뷰와 프레젠터가 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지님

**안드로이드의 MVP**

    뷰: Activity, Fragment가 뷰의 일부로 간주
    Activity가 View <interface>를 구현해서 프레젠터가 코드를 만들 인터페이스를 갖도록 하는 것이 좋음

    프레젠터: 컨트롤러와 역할이 같지만, 뷰에 연결된 것이 아니라 인터페이스이다.
    View <interface>를 받아 로직에 이용
    따라서 MVC의 문제점이었던 '뷰에 단단히 결합'한 것을 해결

### 8. MVVM 패턴

    모델(Model), 뷰(View), 뷰모델(View Model)로 이루어진 디자인 패턴

    뷰모델은 뷰를 더 추상화한 계층

    MVC 패턴과 다르게 뷰와 뷰모델 사이의 양방향 데이터 바인딩과 커맨드를 지원

    장점: UI를 별도 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉬움

**안드로이드의 MVVM**

    뷰모델: Jetpack의 ViewModel 사용
    Data Binding으로 ViewModel이 View를 알지 못해도 다양한 인터렉션 처리 가능
    Model에서 데이터가 변경되면, ViewModel에 알림
    View에 전달되도록 LiveData/ RxJava/ Kotlin Flow 등을 사용해 구현
    
    참고) Android Jetpack의 ViewModel과 MVVM의 ViewModel은 별개이다

    Data Binding: Jetpack의 DataBindig 사용
    레이아웃의 UI 컴포넌트를 데이터에 바인딩할 수 있도록 지원하는 라이브러리

