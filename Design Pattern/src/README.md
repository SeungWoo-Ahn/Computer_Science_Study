## 디자인 패턴
프로그램을 설계할 때 발생했던 문제점들을 
객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 `규약` 형태로 만들어 놓은 것

<br>

### 1. 싱글톤 패턴

    - 하나의 클래스에 '오직 하나의 인스턴스'만 가지는 패턴
    
    - 데이터베이스 연결 모듈에 많이 사용

    - 장점: 같은 인스턴스를 서로 다른 모듈들이 공유하며 사용하기 때문에 인스턴스 생성 비용이 작다.
    그래서 '인스턴스 생성에 많은 비용'이 드는 I/O 바운드 작업(Network, DB, FileSystem)에 많이 사용됨

    - 단점: 
        1. 의존성이 높아진다.
        2. TDD에 걸림돌이 된다
        단위 테스트는 테스트가 서로 독립적이어야 하며 어떤 순서로든 실행할 수 있어야 한다.
        하지만 싱글톤 패턴을 사용하면 각 테스트마다 '독립적인' 인스턴스를 만들기가 어렵다.

    - 단점의 해결책: 의존성 주입
    중간에 의존성 주입자가 하위 모듈에 의존성을 주어, 메인 모듈이 '간접적'으로 의존성을 주입하는 방식
    이를 통해 메인 모듈은 하위 모듈에 대한 의존성이 떨어진다.

### 2. 팩토리 패턴

    - 객체를 사용하는 코드에서 '객체 생성 부분'을 떼어내 '추상화'한 패턴
    상속 관계에 있는 두 클래스에서 상위 클래스는 '중요한 뼈대' 결정, 
    하위 클래스는 '객체 생성'에 관한 구체적인 내용을 결정

    - 장점:
        1. 느슨한 결합: 상위 클래스와 하위 클래스가 분리됨
        2. 유연성: 상위 클래스에선 인스턴스 생성 방식에 대해 알 필요가 없음
        3. 유지 보수성: 객체 생성 로직이 분리돼 한 곳만 고치면 됨

### 3. 전략 패턴

    - 정책 패턴이로고도 하며, 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고
    전략이라고 부르는 '캡슐화한 알고르즘'을 컨텍스트 안에서 바꿔주는 패턴
    ※ 컨텍스트: 상황, 맥락, 문맥을 의미. 개발자가 어떠한 작업을 완료하는데 필요한 모든 정보

    - 하나의 객체가 다양하면서 변화하는 역할을 할 때 사용

    - 예시로 결제할 때, BC카드, 네이버페이, 카카오페이 등 다양한 방법이 있다.
    결제 방식의 '전략'만 바꿔서 결제가 가능하게 만들 수 있다.

### 4. 옵저버 패턴

    - 주체가 객체의 '상태 변화를 관찰'하다가 상태 변화가 있을 때마다
    옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴

    - 주체: 객체의 '상태 변화'를 보고 있는 관찰자

    - MVC 패턴에서 옵저버 패턴
    주체인 '모델'에서 변경 사항이 생기면 옵저버인 '뷰'에 알려주고 이를 기반으로 컨트롤러가 작동

    - 장점
        1. 주체와 객체의 관계를 느슨하게 유지할 수 있다.
        2. 주체의 상태 변경을 주기적으로 조회하지 않고 자동으로 감지
        3. 런타임에 옵저버를 추가하거나 제거할 수 있다.

    - 단점
        1. 복잡도가 증가한다.
        2. 다수의 Observer 객체를 등록 후 해지하지 않으면 '메모리 누수'가 발생할 수 있다.