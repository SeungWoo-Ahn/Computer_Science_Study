## System.out.println()

### 질문

**System.out.println() 메소드의 성능 저하 요인에 대해 설명해주세요.**

    System.out.println은 메서드는 블로킹 I/O이기 때문에 멀티스레드 환경에서 락이 발생해 성능이 떨어질 수 있습니다.
    이유는 메서드 내부에 synchronized block이 사용되기 때문입니다. 따라서 동시에 여러 스레드가 해당 블록에 접근하지 못하고,
    CPU는 메서드가 끝날 때까지 아무 일도 수행하지 못하고 대기해서 성능 저하가 발생합니다.

<br>

**synchronized block을 대체할 수 있는 방법 중 하나인 Lock 인터페이스의 구현체 중에서 속도와 확장성 면에서 성능이 우수한 클래스는 무엇인가요? 그리고 그 클래스의 주요 특징에 대해 설명해주세요.**

    대표적으로 ReentrantLock이 있습니다.
    ReetrantLock은 같은 스레드가 여러 번 재진입이 가능하고, 공정성 설정이 가능합니다.
    synchronized보다 유연하고 빠른 경우가 많고, 스핀락 기반으로 락을 획득하여 경합이 적은 경우 성능이 우수합니다.
    반면에, 경합이 심하면 성능이 급락한다는 단점이 있습니다.

<br>

**ReentrantLock을 사용할 때 경합이 심할 경우에 대처하는 방법은 무엇인가요?**

    ReetrantLock은 경합이 심할 때, 공정성 설정을 통해 대처할 수 있습니다.
    기본적으로 비공정 방식으로 락을 획득하기 때문에 경합이 많다면 오랜 기간 락을 획득하지 못하는 기아 현상이 발생할 수 있습니다.
    공정성 설정을 통해 락을 요청한 순서대로 획득하게 하여 기아 현상을 방지할 수 있지만 성능이 떨어질 수 있다는 단점이 있습니다.

<br>

### System.out.println()은 성능을 저하시킨다

**특징**
- `System`은 java.lang 패키지에 내장된 최종 클래스임
- `out`은 System 클래스의 정적 멤버 필드이고, PrintStream 임
- `println`은 PrintStream 의 메서드이고, 전달된 인자와 줄 바꿈을 출력함

<br>

**내부 코드**

```java
public void println(String x) {
    if (getClass() == PrintStream.class) {
        writeln(String.valueOf(x));
    } else {
        synchronized (this) {
            print(x);
            newLine();
        }
    }
}
```
<br>

**성능 이슈**

`블로킹 I/O`이기에 `멀티스레드 환경에서 락이 발생`함

이유는 `synchronized block` 때문에 동시에 여러 스레드가 해당 블록이나 메서드에 접근하지 못하게 Lock을 걸음

System.out.println()이 끝날 때까지 아무 일도 수행하지 않고 대기해야해서 성능을 저하시킴

<br>

### 성능을 개선한다면?

**ReentrantLock**

특징
- 같은 스레드가 여러 번 재진입 가능함
- 공정성 설정이 가능함 (new ReentrantLock(true)), 먼저 락을 요청한 스레드가 우선적으로 락을 획득하도록 보장함

`synchronized`보다 유연하고 빠른 경우가 많고, 스핀락 기반으로 락을 획득하여 경합이 약할 때 성능이 좋음

반면에 경합이 심하면 성능이 급락함

<br>

**StampedLock**

특징
- 낙관적 락을 지원함
- 읽기-쓰기 락에 특화됨

읽기 작업이 많고, 쓰기가 적은 환경에서 속도가 우수하고,
낙관적 락으로 락 경합이 거의 없고,
멀티 코어 환경에서 확장성이 매우 좋은 장점이 있음

반면에 `ReentrantLock`과 같이 재진입이 불가하고, 코드가 다소 복잡해짐

<br>

**ReentrantReadWriteLock**

특징
- 읽기 락과 쓰기 락을 분리함
- 읽기 락은 여러 스레드가 동시에 접근할 수 있음
- 쓰기 락은 단독으로만 가능함

읽기가 많은 시스템에서 성능이 향상되고, 동일한 스레드가 재진입 가능하단 장점이 있음

반면에 읽기/쓰기 락 전환이 많은 경우 오히려 비효율적임.

