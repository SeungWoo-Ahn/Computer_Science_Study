## Java의 enum

### 질문

**1. enum이란 무엇이고, 어떤 상황에서 사용되는지 설명해주세요.**

    enum이란 java에서 제공하는 열거형 class로, 허용 가능한 값을 제한하여 "type safe"를 제공합니다.
    이를 통해, switch문에서 IDE의 지원을 받으며 사용할 수 있습니다.
    예를 들어, 요일을 나타내는 enum Day를 만들어 Monday ~ Sunday의 객체를 관리할 수 있습니다.
    또 enum은 "Thread safe"하기 때문에 멀티스레딩 환경에서 안전하게 사용할 수 있습니다.

<br>

**2. enum이 "Thread safe"한 이유와 "type safe"를 제공하는 방법은 어떻게 되나요?**

    enum은 클래스 로딩 시점에서 각 상수가 한 번만 초기화되고, 이후 새 인스턴스가 생성되지 않으므로
    여러 스레드가 접근해도 상태가 변하지 않기 때문에 "Thread safe"합니다.
    enum이 "type safe"를 제공하는 방법은 고유한 타입을 제공하고 컴파일 타임에 타입을 검증합니다.
    따라서 잘못된 타입이 들어가면 컴파일 타임에 오류를 검증하고, 
    switch문에서 정의한 enum 상수만 사용할 수 있습니다.

<br>

### 상수를 정의하는 방법

```java
// 1. final 상수
private final static int MONDAY = 1;

// 2. 인터페이스 상수
interface Day {
    int MONDAY = 1;
}

// 3. 자체 클래스 상수
class Day {
    public final static Day MONDAY = new Day();
}
```
1. final 상수
         
`static`을 사용하여 메모리에 한 번만 할당.

그러나 접근 제어자들 때문에 가독성이 좋지 않음.

2. 인터페이스 상수

인터페이스의 멤버는 `public static final` 속성을 생략해서 간결하게 작성 가능.

그러나 컴파일 에러를 검출할 수 없음.

3. 자체 클래스 상수

자체 클래스 인스턴스화를 이용해 상수처럼 사용하는 기법.

그러나 가독성이 안좋고, `switch`문에서 사용할 수 없음.

<br>

### Enum

Java에서 상수를 효과적으로 정리하기 위해 `enum`을 독립된 클래스로 구분함.

핵심은 상수를 객체 지향적으로 `객체화`해서 관리하자는 것.

**enum의 특징**
1. 일종의 객체이기 때문에 `heap 메모리`에 저장되고, 각 enum 요소들은 별개의 메모리 주소를 가짐.
2. 허용 가능한 값을 제한하여 `type safe`를 제공함.
3. `switch`문에서 IDE의 지원을 받으며 사용할 수 있음.
4. `Thread safe`한 `싱글톤 객체`임.

<br>

**enum 메서드 종류**

| method               | 설명                   | 리턴 타입  |
|----------------------|----------------------|--------|
| name()               | 열거 객체의 문자열을 리턴       | String |
| ordinal()            | 열거 객체의 순번을 리턴        | int    |
| compareTo()          | 열거 객체를 비교해 순번 차이를 리턴 | int    |
| valueOf(String name) | 문자열과 일치하는 열거 객체를 리턴  | enum   |
| values()             | 모든 열거 객체들을 배열로 리턴    | enum[] |

<br>

**java.lang.Enum 클래스**

모든 클래스가 `Object` 클래스를 자동 상속하는 것처럼, enum 클래스도 `java.lang.Enum` 클래스를 자동으로 상속 받음.

하지만 `clone()`, `finalize()`, `hashCode()`, `equals()` 4가지 메서드의 오버라이딩을 막기 위해 `final`로 선언함.

이유는 enum은 고유한 상수이기 때문에 오버라이딩해서 바꿔버리면, 고유성이 깨지기 때문임.

<br>

**enum이 Thread-safe한 이유**
1. JVM에서 단 한 번만 인스턴스 화

클래스 로딩 시점에서 각 `enum` 상수가 한 번만 초기화되고, 
그 이후 새 인스턴스가 생성되지 않으므로 여러 스레드가 접근해도 상태가 변하지 않음.

2. enum은 불변 객체

`enum`의 각 상수는 기본적으로 `final`이므로,
한 번 생성된 후 내부 상태가 변경되지 않는 불변 객체임.

3. 지연 로딩이 없는 상수 초기화

`enum` 상수들은 선언되는 동시에 초기화되므로, 이후에 초기화가 발생할 일이 없음.

그래서 스레드 간에 초기화 지연 문제로 충돌이 발생하지 않음.

<br>

**enum이 Type-safe한 이유**

1. 고유한 타입을 제공

`enum`을 정의하면, 해당 타입은 고유한 데이터 타입으로 취급됨. 
그래서 잘못된 타입이 들어가는 것을 방지함.

2. 컴파일 타임에 타입 검증

컴파일 타임에 타입 검증을 통해 오류를 검증하므로, 실행 전 안정성을 보장함.

3. switch문에서 `enum` 사용 시 검증

`swich`문에서 `enum`을 사용할 경우, 사용자가 정의한 enum 상수만을 허용함.