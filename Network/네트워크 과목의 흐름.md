# 네트워크 과목의 흐름

내가 느낀 네트워크 파트는 '다른 컴퓨터와 데이터를 송수신하기 위해 사용되는 네트워크의 
각 계층별 역할과 사용되는 네트워크 기기'를 공부하는 것이다.

`인터넷 프로토콜 스위츠(internet protocol suite)`는 인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 프로토콜의 집합이다.
이를 `TCP/IP 4계층 모델` 혹은 `OSI 7계층`으로 설명한다.
주로 다룰 `TCP/IP 4계층 모델`은 네트워크에서 사용되는 통신 프로토콜의 집합으로
프로토콜의 네트워킹 범위에 따라 네 개의 추상화 계층으로 구성된다.

네트워크 계층마다 사용되는 프로토콜의 종류와 특징, 사용되는 네트워크 기기들을 계층별로 정리할 것이다.

<br>

## 네트워크는 무엇인가

네트워크는 `노드 (node)`와 `링크 (link)`가 서로 연결되어 있으며 리소스를 공유하는 집합이다.
여기서 `노드`의 예시로는 서버, 라우터, 스위치 등 네트워크 장치가 있으며,
`링크`의 예시로는 유선 또는 무선 연결을 뜻한다.

네트워크 용어 중에 링크 내에서 성공적으로 전달된 데이터의 양인 `처리량(throught)`이 있다.
처리량의 단위는 bps(bit per second)이며, 트래픽, 대역폭, 네트워크 중간에 발생하는 에러, 그리고 장치의 하드웨어 스펙에 영향을 받는다.
`트래픽`은 특정 시점에 링크 내에 흐르는 데이터의 양을 말하고,
`대역폭`은 주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수이다.
또 다른 용어인 `지연 시간 (latency)`는 어떤 메세지가 두 장치 사이를 왕복하는데 걸린 시간이다.

네트워크의 노드와 링크가 어떻게 배치되었는지에 대한 방식을 `네트워크 토폴로지`라 한다.
대표적으로 5가지의 네트워크 토폴로지가 있는데,
`트리형`은 트리 형태로 노드와 링크가 연결된 방식이다. 
장점으로는 노드의 추가와 삭제가 쉽지만
단점으로는 트래픽이 집중될 때 트리 형태이기 때문에 하위 노드에 영향을 끼친다.
`버스형`은 중앙 통신 회선 하나에 여러 개의 노드가 연결되어 공유하는 방식이다.
근거리 통신망(LAN)에서 사용되며 장점으로는 설치 비용이 적고 신뢰성이 우수하다. 
또 노드의 추가와 삭제가 쉽다.
하지만 단점으로는 스푸핑이 가능한 문제가 있다.
스푸핑이란 LAN 상에서 송신과 관련 없는 다른 호스트에 가지 않도록 하는 스위칭 기능을 마비시키거나 속여서
송신부의 패킷을 특정 노드에 오도록 처리하는 것이다.
`스타형`은 중앙에 있는 노드에 별처럼 모든 노드가 연결된 방식이다.
장점으로는 노드의 추가, 에러 탐지가 쉽고 패킷 충돌 발생 가능성이 적지만
단점으로는 중앙 노드에 장애가 발생하면 전체 네트워크 사용이 불가능하고 설치 비용이 비싸다.
`링형`은 노드가 고리 모양으로 연결된 방식이다.
장점으로는 노드 수가 증가되어도 네트워크상의 손실이 거의 없고, 충돌 발생 가능성이 적고 고장을 쉽게 발견한다.
단점으로는 네트워크 구성이 어렵고 회선에 장애가 발생하면 전체 네트워크에 영향을 끼친다.
`메시형`은 노드가 그물망처럼 연결된 방식이다.
장점으로는 한 노드에 장애가 발생해도 네트워크를 계속 사용할 수 있고 트래픽 분산 처리가 가능하다.
단점으로는 노드의 추가가 어렵고 구축 비용과 운영 비용이 비싸다.

네트워크 상태를 확인하는 대표적인 명령어 4개가 있다.
`ping`은 네트워크 상태를 확인하려는 대상 노드를 향해 일정 크기의 패킷을 전송하는 명령어다.
패킷 수신 상태와 도달하기까지의 시간 등을 확인할 수 있다.
참고로 TCP/IP 프로토콜 중 ICMP 프로토콜을 통해 동작한다.
`netstat`은 접속되어 있는 서비스들의 네트워크 상태를 표시하는 명령어다.
주로 서비스의 포트가 열려 있는지 확인할 때 사용된다.
`nslookup`은 DNS에 관련된 내용을 확인하는 명령어다.
특정 도메인에 매핑된 ip를 확인할 때 사용한다.
`tracert`는 목적지 노드까지 네트워크 경로를 확인하는 명령어다.
어느 구간에서 응답 시간이 느려지는지 등을 확인할 때 사용한다.

## TCP/IP 4계층과 OSI 7계층은

`TCP/IP 4계층`은 `어플리케이션 계층`, `전송 계층`, `인터넷 계층`, `링크 계층`으로 나눠진다.

TCP/IP 4계층을 OSI 7계층과 대응시켜보면,
`어플리케이션 계층`은 `어플리케이션, 표현, 세션 계층`과 대응되고
`전송 계층`은 똑같이 `전송 계층`과 대응된다.
`인터넷 계층`은 `네트워크 계층`과 대응되고
`링크 계층`은 `데이터 링크, 물리 계층`과 대응된다.

각 계층에는 `PDU (Protocol Data Unit)`이란 계층에서 데이터 덩어리의 단위가 있는데,
제어 관련 정보들이 포함된 `헤더`와 데이터를 의미하는 `페이로드`로 구성된다.
네트워크를 통해 데이터를 송수신할 때,
보내는 측의 제일 상위 계층인 어플리케이션부터 이 계층의 PDU인 `메세지`를 하위 계층으로 보내며 `캡슐화 과정`을 거친다.
`캡슐화 과정`은 상위 계층의 헤더와 데이터를 해당 계층의 데이터 부분에 포함시키고 해당 계층의 헤더를 삽입하는 과정이다.
최종적으로 제일 하위 계층인 물리 계층에서 비트가 되어 받는 쪽으로 전송된다.
받는 측의 제일 하위 계층인 물리 계층부터 어플리케이션 계층까지 `비캡슐화 과정`을 거치며 최종적으로 메세지가 전달된다.
`비캡슐화 과정`은 하위 계층에서 상위 계층으로 가며 각 계층의 헤더 부분을 제거하는 과정이다.
최하위 계층인 물리 계층의 PDU인 비트로 데이터를 송수신하는 것이 가장 빠르고 효율성이 좋지만
어플리케이션 계층에선 헤더에 authorization 등 다른 값들을 넣는 확장이 쉽기 때문에 문자열을 기반으로 송수신한다.

<br>

## 어플리케이션 계층에선

`어플리케이션 계층 (Application Layer)`는 응용 프로그램에 사용되는 프로토콜 계층이며, 실질적으로 서비스를 제공하는 계층이다. 
대표적인 프로토콜로는 `FTP`, `SSH`, `HTTP`, `SMTP`, `DNS`가 있고, PDU는 `메세지`이다.
`FTP`는 장치와 장치 간의 파일을 전송하는데 사용하는 표준 통신 프로토콜이다.
`SSH`는 보안되지 않은 네트워크에서 안전하게 서비스를 운영하기 위한 암호화 네트워크 프로토콜이다.
`HTTP`는 웹 사이트를 이용하는데 쓰는 프로토콜이고, `SMTP`는 전자 메일 전송을 위한 인터넷 표준 프로토콜이다.
`DNS`는 도메인 이름과 IP 주소를 매핑해주는 서버다. 이를 통해, IP 주소가 바뀌어도 사용자에게 똑같은 도메인 주소로 서비스할 수 있다.

어플리케이션 계층의 대표적 프로토콜 중 하나인 HTTP는 HTTP/1.0부터 지금까지 계속 발전해오고 있다.
`HTTP/1.0`은 한 연결당 하나의 요청을 처리하도록 설계됐다.
서버로부터 파일을 가져올 때마다 (전송 계층에서 설명할) TCP 3-way handshake를 열어야해서 패킷 왕복 시간인 `RTT`가 증가하는 단점이 있다.
RTT 증가란 단점을 해결하기 위해 HTTP/1.0에선 `이미지 스플리팅`, `코드 압축`, `이미지 Base64 인코딩`을 사용했다.
`이미지 스플리팅`은 많은 이미지가 합쳐진 하나의 이미지를 다운받고 background-image의 position 속성을 이용해 이미지를 표기하는 방법이다.
합쳐진 이미지를 한 번만, 즉 1-RTT에 받을 수 있게 한 것이다.
`코드 압축`은 코드의 개행 문자, 빈 칸을 없애서 코드의 크기를 최소화하는 방법이다. 이를 통해 코드의 용량이 줄어든다.
`이미지 Base64 인코딩`은 이미지를 64진법으로 이루어진 문자열로 인코딩하는 방법이다.
이를 통해 이미지에 대한 HTTP 요청을 할 필요가 없어진다. 인코딩 결과값인 문자열은 이미지와 동일한 정보를 포함하고 있어 이를 브라우저에서 해석하기 때문이다.
이미지는 기본적으로 바이너리 데이터이고 8비트(1바이트) 단위로 구성된다.
Base64 인코딩은 6비트씩 그룹을 만들어 각 그룹에 해당하는 문자들을 합친 것이다.
인코딩 결과값은 항상 4의 배수 길이의 문자열을 만들어서, 원본 데이터가 3의 배수가 아니라면 "=" 패딩 문자를 결과값에 추가한다.
그래서 용량이 4/3 (약 33% 증가)에 패딩 문자를 포함하는 경우까지 약 37%가 증가한다는 단점이 있다.
이후 `HTTP/1.1`이 등장하는데 한 번 TCP 초기화를 한 이후엔 `keep-alive`란 옵션으로 여러 개의 파일을 송수신할 수 있게 바뀐다.
이를 통해, HTTP/1.0의 문제점인 RTT 증가를 보완했다. 참고로 HTTP/1.0에도 keep-alive가 있었지만 표준화되지 않았다.
하지만 HTTP/1.1에도 문제점들이 존재했는데,
우선 문서 안에 포함된 다수의 리소스(이미지, css/js 파일 등)을 처리하려면 요청 리소스 개수에 따라 대기 시간이 길어진다.
또 네트워크에서 같은 큐에 있는 패킷들이 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상인 `HOL Blocking (Head Of Line Blocking)`이 발생했다.
그리고 헤더에 쿠키 등 많은 메타데이터가 있는데 압축되지 않아 무거운 헤더 구조를 가졌다.
HTTP/1.1의 문제점들을 해결하기 위해 `HTTP/2.0`이 등장했다.
`HTTP/2.0`은 HTTP/1.x보다 지연 시간을 줄이고 응답 시간을 더 빠르게 했다.
이때부터 `멀티플렉싱`, `서버 푸시`, 그리고 `헤더 압축`이 가능해졌다.
`멀티플렉싱`은 여러 개의 스트림을 사용해 송수신하는 것이다.
애플리케이션에서 받아온 메세지를 독립된 프레임으로 조각내어 서로 송수신한 후 다시 조립하며 데이터를 주고 받는 형식이다.
단일 연결을 사용해 병렬적으로 여러 요청을 받을 수 있고 응답을 줄 수 있다.
또 특정 스트림의 패킷이 손실되어도 나머지 스트림은 멀쩔하게 동작이 가능하다.
이를 통해 HTTP/1.1의 문제점인 HOL Blocking을 해결할 수 있게 됐다.
`서버 푸시`는 Client 요청없이 서버가 바로 리소스를 푸시할 수 있는 것을 말한다.
html을 읽으면서 그 안에 있던 css 파일을 서버가 푸시해 Client에게 줄 수 있게 됐다.
`헤더 압축`은 `허프만 코딩 압축 알고리즘`을 사용하는 `HPACK 압축 형식`을 통해 큰 헤더를 압축하는 것이다.
이를 통해 HTTP/1.1의 큰 헤더 문제점을 해결했다.
`허프만 코딩 (huffman coding)`은 문자열을 문자 단위로 쪼개 빈도수를 세서
빈도가 높은 정보는 적은 비트 수를 사용하고,
빈도가 낮은 정보는 비교적 많은 비트 수를 사용해 전체 데이터 표현에 필요한 비트양을 줄이는 알고리즘이다.
좀 더 자세히 설명하면, 각 문자는 겹치지 않는 이진 코드(접두사 코드)를 사용해 표현해야한다.
예를 들어, a라는 문자에 101을 부여하면 b라는 문자는 1, 10, 101을 사용할 수 없다.
이 이진 코드를 만들기 위해 허프만 트리를 활용하는데,
문자열에 등장하는 각 문자의 빈도수를 세서 내림차순으로 정렬한다.
이후 각 문자에 해당하는 노드를 만든 후, 빈도가 작은 순으로 두 노드를 합치면서 하나의 큰 허프만 트리를 만들 수 있다.
루트 노드부터 각 노드에서 왼쪽 간선은 0, 오른쪽 간선은 1을 더하면서 각가의 문자에 대한 이진 코드를 만들면 된다.
이후 `HTTP/3`가 등장했다.
`HTTP/3`는 TCP 위에서 돌아가는 HTTP/2와 달리 `QUIC`이란 계층 위에서 돌아간다.
그리고 TCP가 아닌 `UDP` 기반으로 돌아간다.
`멀티플렉싱`이 가능하고,
QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3-way handshake 과정을 거치지 않아도 되서 
초기 연결 설정 시 지연 시간이 감소한다는 장점이 있다.
즉, 첫 연결 설정에 1-RTT로 Client가 서버에 어떤 신호를 한 번 주고 서버가 응답하면 바로 본 통신이 가능한 것이다.
또 QUIC은 `순방향 오류 수정 메커니즘`이 적용됐다.
전송한 패킷이 손실됐으면, 수신 측에서 에러를 검출하고 수정하는 방식이다.
이것으로 열악한 네트워크 환경에서도 낮은 패킷 손실률을 자랑한다.

HTTP 통신에서 보안을 위해 `HTTPS`가 사용된다.
`HTTPS`는 어플리케이션 계층과 전송 계층 사이에 신뢰 계층인 `SSL/TLS 계층`을 넣은 신뢰할 수 있는 HTTP 요청을 말한다.
이를 통해 통신을 암호화하고, HTTP/2는 HTTPS 위에서 동작한다.
HTTPS를 구축하려면, 직접 `CA에서 구매한 인증키`를 기반으로 HTTPS 서비스를 구축하거나,
서버 앞단에 HTTPS를 제공하는 `로드밸런서`를 둬서 구축하거나,
서버 앞단에 HTTPS를 제공하는 `CDN`을 둬서 구축할 수 있다.
`SSL/TLS`는 `SSL(Secure Socket Layer)`와 `TLS(Transport Layer Security Protocol)`가 있는
전송 계층에서 보안을 제공하는 프로토콜이다. 이를 통해 Client와 서버가 통신할 때, 제 3자가 메세지를 도청하거나 변조하지 못하게 한다.
SSL/TLS에선 `보안 세션`을 기반으로 데이터를 암호화한다.
`보안 세션`은 보안이 시작되고 끝나는 동안 유지되는 세션이다.
`TLS handshake`를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보 등을 공유한다.
보안 세션이 생성될 때, `인증 메커니즘`, `키 교환 암호화 알고리즘`, 그리고 `해시 알고리즘`이 사용된다.
`TLS handshake`는 Client와 서버가 키를 교환하고 이를 기반으로 인증, 인증 확인 등의 작업을 하는
단 한 번의 1-RTT가 생긴 후 데이터를 송수신한다.
먼저, Client가 `사이퍼 슈트`를 서버에 전달하면 서버는 사이퍼 슈트 암호화 알고리즘 리스트를 제공할 수 있는지 확인한다.
제공할 수 있다면, 서버에서 클리이언트로 인증서를 보내는 `인증 메커니즘`이 시작된다.
이후 `해싱 알고리즘` 등으로 암호화된 데이터의 송수신이 시작된다.
`사이퍼 슈트 (cyper suites)`는 프로토콜, AEAD 사이퍼 모드 (데이터 암호화 알고리즘), 해싱 알고리즘이 나열된 규약이다.
예를 들어, "TLS_AES_128_GCM_SHA256"인 사이퍼 슈트에서 
"TLS"는 프로토콜, "AES_128_GCM"은 AEAD 사이퍼 모드, 그리고 "SHA256"은 해싱 알고리즘을 뜻한다.
`인증 메커니즘 (CA, Certificate Authorities)`는 CA에서 발급한 인증서를 기반으로 이루어진다.
CA에서 발급한 인증서는 `공개키`를 클라이언트에 제공하고 사용자가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다.
인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어지고
CA 발급 과정은 자신의 사이트 정보와 공개키를 CA에 제출하면
CA는 공개키를 해시한 값인 지문을 사용하는 CA 비밀키를 기반으로 CA 인증서를 발급한다.
`키 교환 암호화 알고리즘`은 대수곡선 기반의 ECDHE 혹은 모듈식 기반의 DHE를 사용한다.
둘 다 `디피-헬만`방식을 근간으로 만들어졌다.
`디피-헬만 키 교환 (Diffie-Hellman key exchange) 암호화 알고리즘`은 암호키를 교환하는 방식이다.
`y = g^x mod p`란 식에서 g와 x와 p를 안다면 y는 구하기 쉽지만,
g와 y와 p만 안다면 x를 구하기 어렵다는 원리를 기반한 알고리즘이다.
방식은 처음에 Client와 서버가 공개 값을 공유받는다.
공유된 상대방의 공개 값과 각자의 비밀 값을 혼합해 혼합값을 만든다.
해당 혼합값을 상대방과 바꾸고 다시 각자의 비밀 값과 혼합하면 공통의 암호키인 PSK(Pre-Shared Key)가 생성된다.
이를 통해 키를 암호화할 수 있는 것이다.
`해싱 알고리즘`은 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘이다.
대표적인 SHA-256 알고리즘은 해시 함수의 결과값이 256비트인 알고리즘이다.
해싱해야 할 메세지에 1을 추가하는 등의 전처리를 하고, 전처리된 메세지를 기반으로 해시를 반환하는 방식이다.

어플리케이션 계층을 처리하는 기기로는 `L7 스위치`가 있다.
OSI 7계층의 7번째 layer의 스위치란 말이다.
`L7 스위치`는 서버의 부하를 분산하는 기기이며 `로드밸러서`라고도 한다.
시스템이 처리할 수 있는 트래필 증가를 목표로 하며,
Client로부터 오는 요청들을 뒤쪽의 여러 서버로 나누는 역할을 한다.
URL, 서버, 캐시, 쿠키 등을 기반으로 `트래픽을 분산`하고,
`헬스 체크`를 통해 장애가 발생한 서버를 트래픽 분산 대상에서 제외시킨다.
또 필터링 기능과 응용 프로그램 수준의 트래픽 모니터링이 가능하다.
`로드밸러서`는 대표적인 기능으로 `서버 이중화`가 있다.
안정적인 서비스를 운영하려면 2대 이상의 서버가 필수적인데,
로드밸런서는 2대 이상의 서버를 기반으로 사용자에게 가상 IP를 제공하고, 
사용자가 접근하면 뒷단에 사용 가능한 서버로 서빙해 안정적인 서비스를 제공한다.
`헬스 체크 (health check)`는 전송 주기, 재전송 횟수 등을 설정한 이후 반복적으로 서버에 요청을 보내
정상적인 서버, 비정상적임을 판별하는 것이다.
L7 스위치와 (전송 계층에서 설명할) L4 스위치 모두 가능하다.
서버에 부하가 가지 않을 만큼 요청 횟수가 적절해야하며,
TCP, HTTP 등 다양한 방법으로 요청을 보내고 요청이 정상적이라면 정상적인 서버로 판별한다.

<br>

## 전송 계층에선

`전송 계층 (Transport Layer)`는 송신자와 수신자를 연결하는 통신 서비스를 제공하는 계층이다.
대표적인 프로토콜로 `TCP`, `UDP`가 있고, PDU는 TCP의 경우 `세그먼트`, UDP의 경우 `데이터그램`이다.

`TCP`는 패킷 사이의 순서를 보장하고, 연결지향 프로토콜을 사용해서 신뢰성을 구축한다.
또 수신 여부를 확인하기 위해 `가상회선 패킷 교환 방식`을 사용한다.
`가상회선 패킷 교환방식`은 각 패킷에 가상회선 식별자가 포함되서 패킷들이 전송된 `순서대로` 도착한다.
그리고 모든 패킷을 전송하면 가상회선이 해제된다.
`UDP`는 순서를 보장하지 않고 수신 여부를 확인하지 않는다.
단순히 데이터만 주는 `데이터그램 패킷 교환 방식`을 사용한다.
`데이터그램 패킷 교환 방식`은 패킷이 독립적으로 이동하며 최적의 경로를 선택해서 이동한다.
하나의 메세지에서 분할된 패킷들이 서로 다른 경로로 전송될 수 있고, 도착한 순서가 다를 수 있는 방식이다.

TCP에서 Client와 서버가 연결될 때, `3-way handshake` 과정을 거친다.
처음으로 `SYN 단계`에선 Client가 `Client의 ISN`을 담아 서버로 `SYN`을 보낸다.
`SYN (Synchronization)`은 연결 요청 플래그이고, 
`ISN (Initial Sequence Number)`는 첫 번째 패킷에 할당된 임의의 32비트 고유 시퀀스 번호이다.
다음으로 `SYN + ACK 단계`로 서버는 `SYN`으로 `서버의 ISN`과 `ACK`으로 `Client ISN + 1`을 Client로 보낸다.
`ACK(Acknowledgement)`은 응답 플래그이다.
마지막으로 `ACK 단계`로 Client는 `ACK`로 `서버 ISN + 1`을 서버로 보내면서 연결이 성립된다.
이렇게 신뢰성이 구축되고 데이터 전송을 시작한다.
TCP는 이 과정이 있기 때문에 신뢰성이 있는 계층이고, UDP는 이 과정이 없어 신뢰성이 없는 계층이다.
이후 Client와 서버거 연결을 해제할 땐 `4-way handshake` 과정을 거친다.
처음으로 Client가 연결을 닫으려할 때, `FIN`으로 설정된 세그먼트를 서버에 보내며 `FIN_WAIT_1 상태`가 된다.
다음으로 서버는 `ACK`란 승인 세그먼트를 보내며 `CLOSE_WAIT 상태`가 되고, Client는 ACK를 받으면 `FIN_WAIT_2 상태`가 된다.
다음으로 서버는 일정 시간 후에 `FIN`으로 설정된 세그먼틀 Client로 보내며 `LAST_ACK 상태`가 된다.
마지막으로 Client는 서버로 `ACK`를 보내며 `TIME_WAIT 상태`가 된다. 서버는 ACK를 받으면 `CLOSED 상태`가 되며, 
Client는 `TIME_WAIT`에서 일정 시간을 대기한 후 `CLOSED 상태`가 되고 모든 자원의 연결이 해제된다.
`TIME_WAIT 상태`는 소켓이 바로 소멸되지 않고 일정 시간 유지되는 상태이다. 참고로 윈도우는 4분으로 설정됐다.
Client에 TIME_WAIT 상태가 필요한 이유는 `지연 패킷이 발생할 경우`와 `두 장치의 연결이 닫혔는지 확인`하기 위해서다.
패킷이 뒤늦게 도달하고 이를 처리하지 못하면 데이터 무결성 문제가 발생하기 때문에 일정 시간 대기하는 것이다.

전송 계층을 처리하는 네트워크 기기로는 `L4 스위치`가 있다.
`L4 스위치`는 어플리케이션 계층의 `L7 스위치`처럼 `로드밸런서` 역할을 하고, `헬스 체크`도 가능하다.
다만, 스트리밍 관련 서비스에선 사용할 수 없고,
IP와 포트를 기반으로 트래픽을 분산해서 메세지를 기반은 인식하지 못한다.
참고로 `L7 스위치`는 상위 계층의 네트워크 기기이기 때문에 IP와 포트를 기반으로 트래픽 분산이 가능하다.

<br>

## 인터넷 계층에선

`인터넷 계층 (Internet Layer)`는 네트워크 패킷을 IP 주소로 지정된 목적지로 정송하기 위해 사용되는 계층이다.
패킷을 수신해야할 상대의 주소를 지정해서 데이터를 전달하고, 상대방이 제대로 받았는지 보장하지 않는 `비연결적 특성`이다.
대표적인 프로토콜로는 `IP`, `ARP`, `ICMP`가 있고, PDU는 `패킷`이다.

인터넷 계층의 대표적인 프로토콜 중에 `IP`가 있다.
`IP 주소`는 컴퓨터와 컴퓨터간의 통신에 사용되는데,
먼저 `ARP`를 통해 `IP 주소`에서 `MAC 주소`를 찾는다. 그리고 `MAC 주소`를 기반으로 통신하는 것이다.
`ARP (Address Resolution Protocol)`은 IP와 MAC 주소의 다리 역할을 하는 프로토콜이다.
`ARP`는 가상 주소인 IP 주소를 실제 주소인 MAC 주소로 변환하는 것이고,
`RARP`는 실제 주소인 MAC 주소를 가상 주소인 IP 주소로 변환하는 것이다.
ARP 과정을 자세히 설명하면,
먼저 장치 A가 `ARP Request 브로드캐스트`를 보내서 원하는 IP 주소에 해당하는 MAC 주소를 찾는다.
`브로드캐스트`는 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식이다.
그리고 해당 주소에 맞는 장치 B가 `ARP Reply 유니캐스트`를 통해 MAC 주소를 반환하는 과정을 거친다.
`유니캐스트`는 고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 데이터를 전송하는 방식이다.
또 IP 주소를 통해 통신하는 과정을 `홉바이홉 통신`이라 하는데,
통신망에서 각 패킷이 여러 라우터를 건너가는 모습을 비유적으로 표현한 것이다.
즉, 통신 장치에 있는 `라우팅 테이블`의 IP 주소를 통해
시작 주소부터 출발해 다음 IP로 계속해서 이동하는 `라우팅` 과정을 거쳐 패킷이 최종 목적지까지 도달하는 통신을 말한다.

`IP 주소 체계`는 `IPv4`와 `IPv6`로 나뉜다.
`IPv4`는 32비트를 8비트 단위로 점을 찍어 표기하는 것이고,
`IPv6`는 64비트를 16비트 단위로 점을 찍어 표기하는 것이다.
초기에는 A, B, C, D, E 다섯 개의 클래스로 IP 주소를 구분하는 `클래스 기반 할당방식`을 사용했다.
`클래스 A, B, C`는 일대일 통신으로 사용되고, `클래스 D`는 멀티캐스트 통신으로 사용되고
`클래스 E`는 앞으로 사용할 예비용으로 사용하는 방식이다.
여기서 네트워크의 첫 번째 주소는 `네트워크 주소`로 사용되고, 마지막 주소는 `브로드캐스트용 주소`로 사용됐다.
그래서 사용하는 주소보다 버리는 주소가 많은 단점이 있었고,
이를 해소하기 위해 `DHCP`, `IPv6`, `NAT`가 등장했다.
`DHCP (Dynamic Host Configuration Protocol)`은 IP 주소 및 기타 통신 매개변수를 `자동`으로 할당하기 위한 네트워크 관리 프로토콜이다.
이를 통해 인터넷에 접속할 때마다 자동으로 IP 주소를 할당할 수 있어 네트워크 장치의 IP 주소를 수동으로 설정할 필요가 없어졌다.
많은 라우터와 게이트웨이 장비에 DHCP 기능이 있고, 대부분 가정용 네트워크에서 IP 주소를 할당한다.
`NAT (Network Address Translation)`은 패킷이 라우팅 장치를 통해 전송되는 동안
패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매핑하는 방법이다.
`NAT`로 `공인 IP`와 `사설 IP`로 나눠서 많은 주소를 처리할 수 있다.
이는 IPv4 만으로 많은 주소를 감당할 수 없는 문제점을 해결해주었다.
인터넷 공유기로 여러 PC를 연결해 사용할 수 있는데, 인터넷 공유기에 NAT가 탑재됐기 때문이다.
내부 네트워크에서 사용하는 IP 주소와 외부에 드러나는 IP 주소를 다르게 유지해서 어느 정도 보안이 가능한 장점이 있다.
하지만 호스트 숫자에 따라 접속 속도가 느려지는 단점이 있다.

인터넷 계층을 처리하는 네트워크 기기로는 `라우터`와 `L3 스위치`가 았다.
`라우터 (router)`는 여러 개의 네트워크를 연결, 분할, 구분시키는 역할을 한다.
다른 네트워크에 존재하는 장치끼리 서로 데이터를 주고 받을 때,
패킷 소모를 최소화하고 경로를 최적화해 최소 경로로 패킷을 보내는 장비이다.
참고로 라우터의 기능은 소프트웨어 기반, 하드웨어 기반 라우팅으로 나눠진다.
`L3 스위치`는 (링크 계층에서 설명할) `L2 스위치`에 `라우팅` 기능을 갖춘 장비이다.
참조 테이블은 `라우팅 테이블`, 참조 PDU는 `IP 패킷`, 참조 주소는 `IP 주소`이고 하드웨어 기반의 라우팅을 담당한다.
`라우팅 테이블 (routing table)`은 라우터에 들어가 있는 목적지 정보들과 그 목적지로 가기 위한 방법이 들어있는 리스트이다.
송신지에서 수신지까지 도달하기 위해 사용되고,
`게이트웨이`와 모든 목적지로 가기 위해 거쳐야 할 다음 라우터의 정보를 가진다.
참고로 netstat -r 명령어로 확인 가능한 IPv4 경로 테이블, IPv6 경로 테이블이 라우팅 테이블이다.
`게이트웨이 (gateway)`는 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간에 통신을 가능케하는 컴퓨터나 소프트웨어이다.
사용자가 인터넷에 접속하기 위해선 수많은 톨게이트인 게이트웨이를 거쳐야한다.
또 서로 다른 네트워크상의 통신 프로토콜을 변환해주는 역할도 한다.

<br>