## 인덱스

`인덱스`는 데이터를 빠르게 찾을 수 있는 장치임

인덱스를 설정하면 테이블 안에 찾고자 하는 데이터를 빠르게 찾을 수 있음

<br>

### B-트리

**인덱스가 효율적인 이유**

1. 모든 요소에 접근할 수 있는 `균형잡힌 트리 구조`
2. 트리 깊이의 `대수확장성`

    
    대수확장성: 트리 깊이가 리프 노드 수에 비에 매우 느리게 성장하는 것

    기본적으로 인덱스가 한 깊이 증가할 때마다 최대 인덱스 항목의 수는 4배 증가함
    그래서 트리 깊이가 10이라면, 약 100만 개의 레코드를 검색할 수 있음
    실제로는 이것보다 훨씬 효율적임

<br>

**B-트리**

인덱스는 보통 `B-트리`란 자료 구조로 이루어짐

`B-트리`는 `루트 노드`, `리프 노드`, `브랜치 노드`로 나뉨

    브랜치 노드는 루트 노드와 리프 노드 사이에 있음

    예시) 키 57에 해당하는 데이터를 검색해야함

    [39, 83, 88]        <루트 노드>
    [46, 53, 57, 83]    <83에 해당하는 브랜치 노드>
    [55, 57, 57]        <57에 해당하는 리프 노드>

    맨 위 루트 노드부터 브랜치 노드를 거쳐 리프 노드까지 내려오며 탐색함
    '57보다 같거나 클 때까지 <='를 기반으로 왼쪽부터 탐색함
    1) 루트 노드에서 39, 83까지 탐색함. 83이 57보다 크니까 83에 해당하는 브랜치 노드로 이동
    2) 46, 53, 57까지 탐색함. 찾으려는 57과 같은 값이므로 57에 해당하는 리프 노드로 이동
    3) 55, 57까지 탐색함. 찾으려는 57을 찾았으므로 해당하는 데이터 포인터를 통해 결과값을 반환함

<br>

### 인덱스를 만드는 방법

**MySQL에서 (관계형 데이터베이스)**

MySQL엔 `클러스터형 인덱스`와 `세컨더리 인덱스`가 있음

    클러스터형 인덱스
    테이블당 하나를 설정할 수 있음
    1) primary key 옵션으로 기본키를 만들어 생성
    2) 기본키를 만들지 않고 unique not null 옵션으로 생성

    세컨더리 인덱스
    '보조 인덱스'로  여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스
    그래서 하나의 인덱스만 설정할거라면, 클러스터형 인덱스를 만드는 것이 성능이 더 좋음
    1) create index... 명령어로 생성

<br>

**MongoDB에서 (NoSQL 데이터베이스)**

    도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됨
    
    세컨더리키도 부가적으로 설정해서 기본키와 함께 '복합 인덱스'를 설정할 수 있음

<br>

### 인덱스 최적화 기법

`MongoDB`를 기준으로 설명함

(인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 같음)

**1. 인덱스는 비용임**

    인덱스는 두 번 탐색하도록 강요함
    비용1) 인덱스 리스트를 탐색하는 비용
    비용2) 컬렉션을 탐색하는 비용
    그래서 관련 '읽기 비용'이 듦

    컬렉션이 수정되면
    비용1) 인덱스도 수정 비용
    비용2) B-트리 높이를 균형 있게 조절하는 비용
    비용3) 효율적 조회를 위한 데이터를 분산하는 비용
    그래서 '수정 비용'이 듦

    따라서 쿼리에 있는 필드를 무작정 인덱스로 설정하는 것은 답이 아님
    또 컬렉션에서 가져와야할 데이터 양이 많을수록 인덱스를 사용하는 것은 비효율적임

<br>

**2. 테스팅해라**

    서비스에서 사용하는 객체의 깊이, 테이블의 양이 다르기 때문에
    인덱스 최적화 기법은 서비스의 특징에 따라 달라짐
    
    explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 후에 테스팅을 하며 걸리는 시간을 최소화해야함

<br>

**3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순임**

여러 필드를 기반으로 조회할 때, `복합 인덱스`를 생성함

이 인덱스를 생성할 때는 `순서`가 있고, `생성 순서`에 따라 인덱스 성능이 달라짐

    복합 인덱스 생성 순서 (같정다카)

    1. 같음
    어떤 값과 같음을 비교하는 '== or equal'이라는 쿼리를 제일 먼저 인덱스로 설정

    2. 정렬
    정렬에 쓰는 필드라면 그 다음 인덱스로 설정

    3. 다중값
    다중 값을 출력해야 하는 필드
    예를 들어, 쿼리 자체가 '> or <' 같이 많은 값을 출력해야 하는 쿼리에 쓰는 필드를 그 다음 인덱스로 설정

    4. 카디널리티
    카디널리티가 높은 순서를 기반으로 인덱스를 생성해야함
    카디널리티는 데이터의 유니크한 정도임
    예를 들어, age와 email 중 카디널리티가 더 높은 것은 email임