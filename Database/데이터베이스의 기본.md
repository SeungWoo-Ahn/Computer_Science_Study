## 데이터베이스의 기본

**데이터베이스 (DB, DataBase)**

`일정한 규칙`을 통해 구조화되어 저장되는 데이터의 모음

    데이터베이스는 '실시간 접근'과 '동시 공유'가 가능함

<br>

**DBMS (DataBase Management System)**

데이터베이스를 제어, 관리하는 통합 시스템

    데이터 베이스 안에 있는 데이터들은
    특정 DBMS마다 정의된 쿼리 언어(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있음

    데이터베이스 위에 DBMS가 있고, 그 위에 응용 프로그램이 위치함

<br>

### 엔티티

**엔터티 (Entity)**

사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 `명사`

    예시) 회원 엔터티
    속성으로 이름, 아이디, 주소, 전화번호 등등

    약한 엔터티: 혼자서 존재하지 못하고 다른 엔터티 존재 여부에 따라 종속적인 엔터티
    강한 엔터티: 혼자서 존재할 수 있는 엔터티

<br>

###  릴레이션

**릴레이션 (relation)**

데이터베이스에서 정보를 `구분하여 저장`하는 기본 단위

    데이터베이스에선 엔터티에 관한 데이터를 릴레이션 하나에 담아서 관리함

    데이터베이스의 종류)
    1. 관계형 데이터베이스: MySQL
    2. NoSQL 데이터베이스: MongoDB

    관계형 데이터베이스에서 릴레이션: 테이블
    그래서 MySQL의 구조: 레코드 - 테이블 - 데이터베이스

    NoSQL 데이터베이스에서 릴레이션: 컬렉션
    그래서 MongoDB의 구조: 도큐먼트 - 컬렉션 - 데이터베이스

    레코드가 쌓여서 테이블이 되고, 테이블이 쌓여서 데이터베이스가 됨

<br>

### 속성과 도메인

**속성 (attribute)**

릴레이션에서 관리하는 구체적이며 `고유한 이름을 갖는 정보`

<br>

**도메인 (domain)**

릴레이션에 포함된 각각의 속성들이 가질 수 있는 `값의 집합`

    예시) 회원 릴레이션
    속성: 이름, 아이디, 주소, 전화번호, 성별
    도메인: (성별 속성의) 남 or 여

<br>

### 필드와 레코드

예시

| id | name | address | phoneNumber |
|----|------|---------|-------------|
| 0  | 승우   | 경기      | 123         |
| 1  | 찬성   | 서울      | 456         |
| 2  | 두호   | 대구      | 789         |

    id, name, address, phoneNumber 각각이 필드임
    회원 엔티티의 각각의 속성에 해당함

    0, 승우, 경기, 123으로 테이블에 행(row) 단위의 데이터가 레코드임
    레코드를 튜플이라고도 함

<br>

**필드 타입**

필드는 `타입`을 가짐

MySQL을 기준으로 정리함

    1. 숫자 타입

    TINYINT: 1바이트
    SMALLINT: 2바이트
    MEDIUMINT: 3바이트
    INT: 4바이트 (-21억 ~ 21억)
    BIGINT: 8바이트

    2. 날짜 타입

    DATE: 3바이트, 날짜 부분만 있는 값
    1000-01-01 ~ 9999-12-31

    DATETIME: 8바이트, 날짜와 시간 모두 포함한 값
    1000-01-01 00:00:00 ~ 9999-12-31 23:59:59

    TIMESTAMP: 4바이트, 날짜와 시간 모두 포함한 값
    1970-01-01 00:00:01 ~ 2038-01-19 03:14:07

    3. 문자 타입

    CHAR와 VARCHAR 모두 숫자를 입력해 몇 자까지 입력할지 정함
    예) CHAR(30): 최대 30자까지 입력할 수 있음

    1) CHAR: 고정 길이의 문자열, 길이 0 ~ 255
    레코드를 저장할 때 무조건 선언한 길이 값으로 '고정'해서 저장됨
    CHAR(100)으로 선언하면 10글자를 저장해도 100바이트로 저장됨

    2) VARCHAR: 가변 길이 문자열, 길이 0 ~ 65535
    입력된 데이터에 따라 용량을 가변시켜 저장함
    VARCHAR(1000)이어도 10글자를 저장하면, 10글자에 해당하는 바이트 + 길이기록용 1바이트 = 11바이트로 저장됨

    그래서 CHAR은 유동적이지 않은 길이를 가진 데이터의 경우에 효율적이고,
    VARCHAR은 유동적인 길이를 가진 데이터를 저장하는데 좋음

    3) TEXT: 큰 문자열 저장에 사용됨 (게시판의 본문을 저장할 때 사용)

    4) BLOB: 이미지, 동영상 등 큰 데이터 저장에 사용함
    (S3를 사용하는 경우, 서버에 파일을 올리고 파일 경로를 VARCHAR로 저장함)

    5) ENUM
    선언한 요소 중 하나만 선택하는 '단일 선택'만 가능함
    ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됨
    선언된 요소들이 0, 1 등으로 매핑되어 메모리를 적게 사용함
    최대 65,535개의 요소를 넣을 수 있음

    6) SET
    ENUM과 비슷하지만 `여러 개를 선택` 가능함
    비트 단위의 연산을 할 수 있음
    최대 64개의 요소를 넣을 수 있음

    ENUM과 SET은 모두 문자열을 열거한 타입임
    공간적으로 이점을 볼 수 있지만,
    어플리케이션 수정에 따라 ENUM이나 SET에서 정의한 목록을 수정해야함

<br>

### 관계

데이터베이스에는 여러 개의 테이블이 있고, 테이블들은 서로 관계가 정의되어 있음

이러한 관계를 `관계화살표로 나타냄`

![관계 화살표](https://github.com/user-attachments/assets/fa6e9288-b384-4ede-a7c7-9958c93d2593)

<br>

**1:1 관계**

    유저당 이메일은 한 개씩 있음, 이러한 경우 1:1 관계가 됨
    1:1 관계는 테이블을 두 개의 테이블로 나눠 구조를 더 이해하기 쉽게 만들어줌

    유저      (1:1)       유저 이메일
    - 이름                - 이름
    - 주소                - 이메일 
    - 전화번호

<br>

**1:N 관계**

    쇼핑몰에서 한 유저당 여러 상품을 장바구니에 넣을 수 있음, 이러한 경우 1:N 관계가 됨
    한 개체가 다른 많은 개체를 포함하는 관계임

    유저      (1:N)       상품
    - 이름                - 이름
    - 주소                - 가격
    - 전화번호

<br>

**N:M 관계**

    학생과 강의의 관계에서,
    학생도 강의를 많이 들을 수 있고 강의도 여러 명의 학생을 포함할 수 있음
    이러한 경우에 N:M 관계가 됨

    N:M 관계는 두 개의 테이블을 직접 연결해서 구축하지 않고,
    1:N, 1:M이라는 관계를 갖는 테이블 두 개로 나눠서 설정함

    학생      (1:N)       학생_강의       (M:1)       강의
    - id                 - 학생 id                   - id
    - 이름               - 강의 id                    - 이름
    - 주소                                           - 교수명

<br>

### 키

테이블 간의 관계를 좀 더 명확하게 하고, 테이블 자체의 `인텍스`를 위해 설정된 장치

`기본키`, `대체키`, `후보키`, `슈퍼키`, `외래키`가 있음

용어)
- 유일성: 중복되는 값이 없음
- 최소성: 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것

![키의 관계](https://github.com/user-attachments/assets/2ebac147-d527-45db-92de-7a9061ed00ef)

<br>

**기본키 (PK, Primary Key)**

    유일성과 최소성을 만족하는 키
    테이블 데이터 중 '고유하게 존재하는 속성'
    그래서 중복되면 안됨

    기본키는 자연키와 인조키 중 골라서 사용함

    자연키: 속성들 중에 중복되지 않는 것을 자연스레 뽑다가 나오는 키
    예를 들면, 주민등록번호
    그래서 자연키는 언젠가 변하는 속성을 가짐

    인조키: 인위적으로 생성한 키
    예를 들어, 인위적으로 부여한 유저 아이디
    변하지 않는 속성 때문에 보통 기본키는 인조키로 설정함

<br>

**후보키 (candidate key)**

    기본키가 될 수 있는 후보들로 유일성과 최소성을 동시에 만족함

**대체키 (alternate key)**

    후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들

**슈퍼키 (super key)**

    각 레크드를 유일하게 식별할 수 있는 유일성을 갖춘 키

**외래키 (FK, Foreign Key)**

    다른 테이블의 기본키를 그대로 참조하는 값
    개체와의 관계를 식별하는 데 사용함
    그래서 중복되어도 괜찮음

    예) client에 부여된 id를 product의 소유주를 나타내기 위해 user_id로 사용하는 경우


        
