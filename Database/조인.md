## 조인

`조인(join)`은 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

    MySQL에선 'JOIN'이란 쿼리로 처리
    MongoDB에선 'lookup'이란 쿼리로 처리
    (참고로 lookup은 RDBMS보다 성능이 떨어지므로 되도록 사용하지 않음)

    그래서 여러 테이블을 조인하는 작업이 많으면 관계형 데이터베이스를 사용해야함

<br>

### 조인의 종류

**사용할 예시**

조인의 종류를 정리하며 다음과 같은 테이블 두 개를 예시로 사용함

`Table A`

| 상품코드 | 상품명 |
|------|-----|
| 1    | a   |
| 2    | b   |
| 3    | c   |
| 4    | d   |
| 5    | e   |

`Table B`

| 상품코드 | 재고수량 |
|------|------|
| 1    | 100  |
| 3    | 200  |
| 4    | 300  |
| 7    | 400  |
| 8    | 500  |

<br>

**내부 조인 (inner join)**

왼쪽 테이블과 오른쪽 테이블의 두 행이 `모두 일치하는 행`이 있는 부분만 표기함

즉, 두 테이블의 `교집합`을 나타냄

```sql
SELECT A.상품코드 상품코드, A.상품명 상품명, B.재고수량 재고수량  // 조회할 컬럼
    FROM TABLE ( A ) as A   // 결합할 테이블 명, 'as' 이후는 별칭
        INNER JOIN TABLE ( B ) as B
        ON A.상품코드 = B.상품코드  // 결합 조건
```

`결과`

| 상품코드 | 상품명 | 재고수량 |
|------|-----|------|
| 1    | a   | 100  |
| 3    | c   | 200  |
| 4    | d   | 300  |

<br>

**왼쪽 조인 (left outer join)**

`Table A를 기준`으로 Table B의 일치하는 부분의 레코드와 함께 완전한 레코드 집합을 생성함

만약 Table B에 일치하는 항목이 없으면, 해당 값은 `null 값`이 됨

```sql
SELECT A.상품코드 상품코드, A.상품명 상품명, B.재고수량 재고수량
    FROM TABLE ( A ) as A
        LEFT JOIN TABLE ( B ) as B
        ON A.상품코드 = B.상품코드
```

`결과`

| 상품코드 | 상품명 | 재고수량 |
|------|-----|------|
| 1    | a   | 100  |
| 2    | b   | null |
| 3    | c   | 200  |
| 4    | d   | 300  |
| 5    | e   | null |

<br>

**오른쪽 조인 (right outer join)**

`Table B를 기준`으로  Table A의 일치하는 부분의 레코드와 함께 완전한 레코드 집합을 생성함

만약 Table A에 일치하는 항목이 없으면, 해당 값은 `null 값`이 됨

```sql
SELECT A.상품코드 상품코드, A.상품명 상품명, B.재고수량 재고수량
    FROM TABLE ( A ) as A
        RIGHT JOIN TABLE ( B ) as B
        ON A.상품코드 = B.상품코드
```

`결과`

| 상품코드 | 상품명  | 재고수량 |
|------|------|------|
| 1    | a    | 100  |
| 3    | c    | 200  |
| 4    | d    | 300  |
| 7    | null | 400  |
| 8    | null | 500  |

<br>

**합집합 조인 (완전 외부 조인, full outer join)**

양쪽 테이블에서 일치하는 레코드와 함께 Table A와 Table B의 `모든 레코드` 집합을 생성함

만약 일치하는 항목이 없으면, 누락된 쪽에 `null 값`이 포함됨

```sql
SELECT A.상품코드 상품코드, A.상품명 상품명, B.재고수량 재고수량
    FROM TABLE ( A ) as A
        FULL JOIN TABLE ( B ) as B
        ON A.상품코드 = B.상품코드
```

`결과`

| 상품코드 | 상품명  | 재고수량 |
|------|------|------|
| 1    | a    | 100  |
| 2    | b    | null |
| 3    | c    | 200  |
| 4    | d    | 300  |
| 5    | e    | null |
| 7    | null | 400  |
| 8    | null | 500  |

<br>

## 조인의 원리

**중첩 루프 조인 (NLJ, Nested Loop Join)**

`중첩 for문`과 같은 원리로 조건에 맞는 조인을 하는 방법

    대용량의 테이블에선 사용하지 않음
    랜덤 접근에 대한 비용이 많이 증가하기 때문에

    ※ 블록 중첩 루프 조인 (BNL, Block Nested Loop) 방식도 있음
    조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인하는 방법

```text
[의사 코드]
for each row in t1 matching reference key {
    for each row in t2 matching reference key {
        if row satisfies join conditions, send to client
    }
}
```

<br>

**정렬 병합 조인**

1. 각각의 테이블을 조인할 필드 기준으로 `정렬함`
2. 정렬 이후에 조인 작업을 수행함


    [사용 조건]
    1) 조인할 때 쓸 적절한 인덱스가 없고
    2) 대용량의 테이블을 조인하고
    3) 조인 조건으로 범위 비교 연산자(<, > 등)이 있을 때

<br>

**해시 조인**

`해시 테이블`을 기반으로 조인하는 방법

    두 개의 테이블 중 하나의 테이블이 메모리에 온전히 들어간다면,
    중첩 루프 조인보다 효과적임

    동등(=) 조인에서만 사용할 수 있음

    MySQL에선 해시 조인이 빌드 단계, 프로브 단계로 나뉨
    사용 예시) users 테이블과 countries 테이블을 해시 조인할 것임

    1. 빌드 단계
    입력 테이블 중 하나를 기반으로 메모리 내 '해시 테이블'을 빌드하는 단계
    조인에 사용되는 필드가 해시 테이블의 키로 사용됨
    1) users 테이블과 countries 테이블 중 바이트가 더 작은 countries를 기반으로 해시 테이블을 생성함
    2) 조인에 사용될 countries.country_id가 키로 사용됨

    2. 프로브 단계
    레코드 읽기를 시작하며 각 레코드에서 해시 테이블의 키에 일치하는 레코드를 찾아서 결과값으로 반환함
    1) users 테이블의 각 레코드에서 'users.country_id'에 일치하는 값을 반환함

    이를 통해, 각 테이블은 한 번씩만 읽게 됨
    그래서 보통 중첩 루프 조인보다 성능이 더 좋음
    