# 운영체제 과목의 흐름

운영체제 파트를 정리하며 운영체제란 과목이란 무얼 위해 배울까를 생각해보았다.

내가 느낀 운영체제 파트는 '개발자가 만든 프로그램을 사용자가 사용할 때, 
컴퓨터에서 일어나는 일련의 과정'을 공부하는 것이다.

사용자가 프로그램을 실행하면,
1. 사용자가 보조기억장치에 위치한 프로그램을 실행하면 
2. 프로그램은 주기억장치에 올라가 인스턴스화를 통해 프로세스가 되고  
3. 운영체제의 CPU 스케줄러에 따라 
4. CPU에서 프로세스를 처리한다.

<br>

## 소스코드에서 프로그램으로

개발자가 만든 소스코드 파일은 컴파일 과정을 거쳐 실행 가능한 파일로 변환된다.

우선 주석을 제거하고 헤더 파일을 병합하여 메크로로 치환하는 `전처리 과정`을 거친다.
그 후 `컴파일러`를 통해 오류를 처리하고 코드를 최적화해 `어셈블리어`로 변환된다.
다음으로 `어셈블러`를 통해 어셈블리어는 `목적 코드`로 변환되고, 
`링커`를 통해 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합해 .exe나 .out 확장자를 가진 `실행 파일`이 만들어진다.

참고로 `링커`에서 결합되는 라이브러리는 정적 라이브러리, 동적 라이브러리로 두 가지 종류가 있는데,
정적 라이브러리는 프로그램 빌드 시, 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식이라 외부 의존도가 낮지만 메모리 효율성이 떨어진다.
동적 라이브러리는 프로그램 실행 시, 필요할 때만 DLL이란 함수 정보를 통해 참조하여 라이브러리를 사용하는 방식이다.

<br>

## 사용자가 프로그램을 실행하면

운영체제의 구조는 맨 위에 응용 프로그램이 있고 
그 아래에 `GUI 인터페이스`, `시스템 콜`, `커널` 순으로 운영체제가 존재하고
맨 아래 CPU, 메모리, I/O 디바이스 등을 칭하는 하드웨어가 위치한다.

운영체제를 한 마디로 설명하자면 `사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스`이다.

사용자는 `GUI 인터페이스`를 이용해 아이콘을 클릭해 원하는 프로그램을 실행한다.
이제 아래 `시스템 콜`을 이용하게 되는데, 시스템 콜은 `운영체제가 커널에 접근하기 위한 인터페이스`이다.
컴퓨터 자원에 대해 `유저 모드`, `커널 모드`란 두 가지 모드가 있는데, 유저 모드는 유저가 접근할 수 있는 제한적 모드이고
커널 모드는 모든 컴퓨터 자원에 접근할 수 있는 모드이다. 시스템 콜을 통해 유저 모드에서 커널 모드로 변환되어 프로그램을 실행할 수 있는 것이다.
우리는 아이콘을 더블 클릭해서 프로그램을 실행했는데, 클릭은 하나의 I/O 요청이고 이것은 `인터럽트`(여기선 트랩)를 발생시킨다.
`인터럽트`는 프로그램 실행 중 예기치 않은 상황이 발생할 때, 실행중인 작업을 잠시 중단하고 (CPU 잠깐 정지) 발생된 상황을 처리한 뒤 실행중인 작업으로 다시 복귀하는 것을 말한다.
시스템 콜을 통해 이 클릭이 올바른 I/O 요청인지 확인 후 유저 모드가 커널 모드로 변환되어 실행된다. 
좀 더 자세히는 인터럽트가 발생하면 커널의 인터럽트 종류마다 번호를 정하고 번호에 따라 처리해야되는 코드가 위치한 부분을 가르키고 있는 `인터럽트 벡터`로 이동한다.
그리고 발생한 인터럽트에 해당하는 `인터럽트 서비스 루틴(ISR, 인터럽트 핸들러 함수)`를 실행하고 다시 유저 모드로 변환된다.

시스템 콜 덕분에 컴퓨터 자원에 대한 직접 접근을 차단하고 프로그램을 다른 프로그램으로부터 보호할 수 있다.
또 시스템 콜은 인터페이스로 하나의 추상화 계층이기 때문에 낮은 단계 영역(데이터 베이스, 네트워크 등)을 신경 쓰지 않고 프로그램을 구현할 수 있다.
참고로 유저 모드와 커널 모드는 modebit란 플래그 변수를 참고해서 구분하는데, 유저 모드의 modebit은 1이고 커널 모드의 modebit은 0이다.

인터럽트는 하드웨어 인터럽트, 소프트웨어 인터럽트로 나뉘는데,
하드웨어 인터럽트는 외부 인터럽트로 키보드, 마우스 같은 I/O 장치에서 발생시키는 인터럽트를 말한다.
(컴퓨터 구조에서 설명할) 디바이스 컨트롤러가 CPU 인터럽트 라인을 세팅하고 인터럽트 발생을 통보하면 CPU는 하던 일을 멈추고 인터럽트를 처리한다.
예시로는 I/O 인터럽트, 전원 인터럽트, (컴퓨터 구조에서 설명할) 타이머 인터럽트가 있다.
소프트웨어 인터럽트는 내부 인터럽트로 0으로 나누기, 오버플로우 등의 오류에 해당하는 Exception 인터럽트 (트랩, trap)이 있고
open("a.txt") 같은 명령어가 들어왔을 때, 시스템 콜 호출을 위한 SVC 인터럽트가 있다.

이렇게 운영체제는 커널 함수를 제공하는것 뿐만 아니라
CPU 소유권을 어떤 프로세스에 할당할지 정하는 `CPU 스케줄링`과 프로세스의 생성과 삭제, 자원의 할당과 반환을 관리하는 `프로세스 관리`
한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리하는 `메모리 관리`,
디스크 파일을 어떤 방법으로 보관할지 관리하는 `디스크 파일 관리`,
그리고 I/O 디바이스와 컴퓨터 간에 데이터를 주고받는 것을 관리하는 `I/O 디바이스 관리`를 담당한다.

<br>

## 프로그램이 올라갈 메모리는

메모리 계층은 위에서부터 `레지스터`, `캐시`, `주기억장치`, `보조기억장치`가 있다.

`레지스터`는 CPU 안에 있는 매우 빠른 임시기억장치로 CPU는 자체적으로 데이터를 저장할 방법이 없기 때문에 레지스터를 거쳐 데이터를 전달한다.
`캐시`는 L1, L2, L3 캐시를 지칭한다.
`주기억장치`는 `RAM (Random Access Memory)`를 말한다. 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 필요할 시에 CPU에 빠르게 전달하는 역할을 한다.
`보조기억장치`는 HDD, SSD를 일컬어 말한다.
높은 계층일수록 속도가 빠르고 용량이 작지만 가격은 비싸다.
또 레지스터, 캐시, 주기억장치는 휘발성인 반면에 보조기억장치는 비휘발성인 특징을 갖고 있다.

두 번째의 `캐시 (cache)` 계층이 생소한데, 이는 데이터를 미리 복사해 놓는 임시 저장소이다.
빠른 장치와 느린 장치의 속도 차이에 의한 병목 현상을 줄이기 위한 메모리이다.
캐시에 원하는 데이터가 있을수도 없을수도 있다.
CPU의 제어장치가 캐시에서 원하는 데이터를 찾으면 이를 캐시 히트라 한다. 이때, 캐시에서 데이터를 제어장치를 통해 가져오는데 CPU 내부 버스를 기반으로 작동해서 빠르다.
반면 캐시에서 원하는 데이터가 없으면 캐시 미스라 한다. 이때, 메모리에서 데이터를 가져오는데 시스템 버스를 기반으로 작동해서 느리다.
캐시가 히트되기 위해선 메모리에서 캐시로 데이터를 미리 세팅해야하는데 이를 `캐시 매핑`이라 한다.
캐시 매핑에는 3가지 방법이 있는데 메모리가 1~100, 캐시가 1~10이 있다는 예시로 설명하자면,
`직접 매핑`은 캐시 1에는 메모리 1~10, 캐시 2에는 메모리 11~20.. 식으로 매핑하는 것이다. 처리가 빠르지만 충돌 발생이 잦아 성능이 떨어진다.
`연관 매핑`은 순서를 일치시키지 않고 캐시 어디든 메모리를 매핑하는 것이다. 충돌은 적지만 모든 블록을 탐색해야해서 속도가 느리다.
`집합 연관 매핑`은 캐시 1~5에는 메모리 1~50을 무작위로 매핑시키는 것이다. 즉, 순서를 일치시키지만 집합을 둬서 매핑하여 검색이 더 효율적이다.
