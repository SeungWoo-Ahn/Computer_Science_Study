## CPU 스케줄링 알고리즘

`CPU 스케줄링 알고리즘`이 어떤 프로그램에 CPU 소유권을 줄 것인지 결정함

**목표**
1. CPU 이용률이 높게
2. 주어진 시간에 많은 일을 하도록
3. 준비 큐 (ready queue)에 있는 프로세스는 적게
4. 응답 시간은 짧게

**종류**
1. 비선점형 방식 (non-preemptive)
   1. FCFS (First Come, First Served)
   2. SJF (Shortest Job First)
   3. 우선순위


2. 선점형 방식 (preemptive)
   1. 라운드 로빈 (Round Robin)
   2. SRF (Shortest Remaining Time First)
   3. 다단계 큐

<br>

### 비선점형 방식

    프로세스가 '스스로 CPU 소유권을 포기'하는 방식
    즉, 강제로 실행중인 프로세스를 중지하지 않음

    따라서 컨텍스트 스위칭에 의한 부하가 적은 장점이 있음

**FCFS**

    FCFS (First Come, First Served)
    가장 먼저 온 것을 가장 먼저 처리하는 알고리즘

    '준비 큐에서 오래 기다리는 현상(convoy effect)'가 발생하는 단점

**SJF**

    SJF (Shortest Job First)
    실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘

    장점: 평균 대기 시간이 가장 짧음
    단점: 긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation)이 발생함

    실제 실행 시간은 알 수 없어서 과거의 실행했던 시간을 토대로 추측해 사용함

    비선점형이기 때문에 실행 시간이 짧은 프로세스가 들어왔다해도 실행중인 프로세스가 완료될 때까지 대기함

**우선순위**

    오래된 작업일수록 '우선순위를 높이는 방법(align)'을 사용해 보완한 알고리즘

    ※ 선점형 방식으로도 우선순위 알고리즘을 사용할 수 있음

<br>

### 선점형 방식

    현재 사용중인 프로세스를 알고리즘에 의해 '중단'시키고 
    '강제'로 다른 프로세스에 CPU 소유권을 할당하는 방식

    현대 운영체제가 쓰는 방식

**라운드 로빈**

    라운드 로빈 (Round Robin)
    1. 각 프로세스에 동일한 할당 시간은 줌
    2. 시간 안에 끝나지 않으면 다시 준비 큐의 맨 뒤로 돌아감

    if (할당 시간이 너무 길면)
        FCFS가 됨
    if (할당 시간이 너무 짧으면)
        컨텍스트 스위칭이 잦아져 오버헤드 발생함

    일반적으로,
    전체 작업 시간은 길어지지만
    평균 응답 시간은 짧아짐

    ※ 로드밸런서에서 트래픽 분산 알고리즘으로도 쓰임

**SRF**

    SRF (Shortest Remaining Time First)
    1. 중간에 더 짧은 작업이 들어오면
    2. 수행하던 프로세스를 중지하고
    3. 더 짧은 작업을 수행하는 알고리즘

    SJF과 마찬가지로 기아 현상(starvation)이 발생할 수 있음

**다단계 큐**

    '우선순위'에 따른 '준비 큐를 여러 개 사용'하고 '큐마다 다른 스케줄링 알고리즘'을 적용한 것

    큐 간의 프로세스 이동이 안되므로
    장점: 스케줄링 부담이 적음
    단점: 유연성이 떨어짐, 우선순위 상위 큐에 프로세스가 계속 들어온다면 하위 큐의 작업을 할 수 없음

    예시)
    foreground 처럼 반응속도가 빨라야하는 프로세스는 타임퀀텀을 짧게하고
    background 처럼 반응속도가 느려도되는 프로세스는 타임퀀텀이 긴 FCFS를 사용함

    ※ 타임퀀텀 (time quantum): CPU를 사용할 수 있는 최대 시간

    ※ 다단계 피드백 큐: 다단계 큐의 단점을 보완하기 위해 등장 (현대 운영체제의 스케줄링 방식)
    1. CPU를 사용한 프로세스는 우선순위가 낮아짐
    2. 큐 사이로 프로세스가 이동 가능함
    3. aging 기법을 활용해 오래 기다린 프로세스를 상위 큐로 격상시킬 수 있음
    4. 우선순위가 낮아질수록 타임퀀텀이 커지고 마지막 큐는 FCFS로 CPU를 뺏기지 않고 프로세스 완료 가능




    